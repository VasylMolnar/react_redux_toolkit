1 ) Post.jsx and UpdatePost.jsx

    export const selectPostById = (state, postId) => { // postSlice.js
      return state.posts.posts.find(post => post.id === postId);
    };


    before

    const posts = useSelector(selectAllPosts);
    const post = posts.find(post => post.id.toString() === id);

    after

    const post = useSelector(state => selectPostById(state, id));


2 ) Users.jsx and UserPage.jsx (React dev tools)  (this method works as useMemo in React)
    (in Nav.jsx click on the button)  Profile
    import createSelector from "@reduxjs/toolkit";

    before (img 1)
     (UserPage.jsx)
      const postsForUser = useSelector(state => selectPostsByUser(state, id));


      (postSlice.js)
      export const selectPostsByUser = (state, id) => {       
        return state.posts.posts.filter(post => post.userId === Number(id));
      };


    after (img 2) now UserPage.jsx not rendered if we click on the button. and filter not created new array in render because createSelector works as useMemo in React.
      (UserPage.jsx)
      const postsForUser = useSelector(state => selectPostsByUser(state, id));

      (postSlice.js)
      export const selectPostsByUser = createSelector(
        [selectAllPosts, (state, id) => id],
        (posts, id) => posts.filter(post => post.userId === Number(id))
      );


3 ) Posts.jsx and PostCard.jsx use Memo to fix the problem.
    (Each component is rendered. When we click the button on only one component (other components should not be rendered))

    before (img 3)
    const PostCard = ({ post }) => {
        if (!post) {
          Notify.warning('List is empty.');
          return (
            <section className="section post">
              <h1 className="container  text-warning text-center">List is empty.</h1>
            </section>
          );
        }

        return(
          <div
            className="card"
            key={post.id}
            style={{ margin: '10px', cursor: 'pointer' }}
          >
            <Link
              to={`/posts/${post.id}`}
              className="card-body"
              style={{ textDecoration: 'none' }}
            >
              <h3 className="card-title">{post.title}</h3>
              <p className="card-name">
                <PostAuthor userId={post.userId} />
              </p>
              <p className="card-body">{post.content}</p>
              <p className="card-date">
                <TimeAgo timestamp={post.date} />
              </p>
            </Link>
            <div className="button_list">
              <ReactionButtons reactions={post.reactions} id={post.id} />
            </div>
          </div>
        );
    };

    export default PostCard;


    after (img 4) //now PostCard not be rendered if {posts} not be changed (this method can fix problems (and other components not be rendered only components on which the button was clicked))
    let PostCard = ({ post }) => {
      if (!post) {
        Notify.warning('List is empty.');
        return (
          <section className="section post">
            <h1 className="container  text-warning text-center">List is empty.</h1>
          </section>
        );
      }

      return (
        <div
          className="card"
          key={post.id}
          style={{ margin: '10px', cursor: 'pointer' }}
        >
          <Link
            to={`/posts/${post.id}`}
            className="card-body"
            style={{ textDecoration: 'none' }}
          >
            <h3 className="card-title">{post.title}</h3>
            <p className="card-name">
              <PostAuthor userId={post.userId} />
            </p>
            <p className="card-body">{post.content}</p>
            <p className="card-date">
              <TimeAgo timestamp={post.date} />
            </p>
          </Link>
          <div className="button_list">
            <ReactionButtons reactions={post.reactions} id={post.id} />
          </div>
        </div>
      );
    };

    PostCard = React.memo(PostCard); //now PostCard not be rendered if {posts} not be changed
    export default PostCard;


4 ) Posts.jsx and PostCard.jsx method 2 (createEntityAdapter) this code faster

    before(img 3)
      Posts.jsx
              const posts = useSelector(selectAllPosts);

              {status === 'succeeded' &&
                !error &&
                (Loading.remove(500),
                sortPosts
                  .reverse()
                  .map(post => <PostCard post={post} key={post.id} />))}


      PostCard.jsx
              const PostCard = ({ post }) => {

                if (!post) {
                  Notify.warning('List is empty.');
                  return (
                    <section className="section post">
                      <h1 className="container  text-warning text-center">List is empty.</h1>
                    </section>
                  );
                }

                return (
                  <div
                    className="card"
                    key={post.id}
                    style={{ margin: '10px', cursor: 'pointer' }}
                  >
                    <Link
                      to={`/posts/${post.id}`}
                      className="card-body"
                      style={{ textDecoration: 'none' }}
                    >
                      <h3 className="card-title">{post.title}</h3>
                      <p className="card-name">
                        <PostAuthor userId={post.userId} />
                      </p>
                      <p className="card-body">{post.content}</p>
                      <p className="card-date">
                        <TimeAgo timestamp={post.date} />
                      </p>
                    </Link>
                    <div className="button_list">
                      <ReactionButtons reactions={post.reactions} id={post.id} />
                    </div>
                  </div>
                );
              };

              export default PostCard;


      postSlice.js(here is the code that will change) the last code is unchanged
              const initialState = {
                posts: [],
                status: 'idle', //'idle' | 'loading' | 'succeeded' | 'failed'
                fetchError: null,
                count: 0,
              };

              const postSlice = createSlice({
                name: 'posts',
                initialState,
                reducers: {
                  //or postUpdate can work as reactionAdded
                  reactionAdded(state, action) {
                    const { postId, reaction } = action.payload;
                    const existingPost = state.posts.find(post => post.id === postId);

                    if (existingPost) {
                      existingPost.reactions[reaction]++; //is work
                    }
                  },

                  increaseCount(state, action) {
                    state.count += 1;
                  },
                },
                extraReducers(builder) {
                  builder
                    .addCase(fetchPosts.pending, (state, action) => {
                      state.status = 'loading';
                    })
                    .addCase(fetchPosts.fulfilled, (state, action) => {
                      state.status = 'succeeded';
                      state.posts = action.payload;
                    })
                    .addCase(fetchPosts.rejected, (state, action) => {
                      state.status = 'failed';
                      state.error = action.error.message;
                    })
                    .addCase(apiRequest.fulfilled, (state, action) => {
                      // state.posts.push(action.payload)
                      state.status = 'idle';
                    });
                },
              });

              export const selectAllPosts = state => state.posts.posts;
            
              export const selectPostById = (state, postId) => {
                const post = state.posts.posts.find(post => post.id === postId);

                if (!post) {
                  Report.failure('Post not found', '');
                  return [];
                }
                return post;
              };


    after(img 5)
        Posts.jsx
              const orderedPostIds = useSelector(selectPostIds);

              {status === 'succeeded' &&
                !error &&
                (Loading.remove(500),
                orderedPostIds.map(postIds => (
                  <PostCard postIds={postIds} key={postIds} />
                )))}


        PostCard.jsx
              const PostCard = ({ postIds }) => {
                const post = useSelector(state => selectPostById(state, postIds));

                if (!post) {
                  Notify.warning('List is empty.');
                  return (
                    <section className="section post">
                      <h1 className="container  text-warning text-center">List is empty.</h1>
                    </section>
                  );
                }

                return (
                  <div
                    className="card"
                    key={post.id}
                    style={{ margin: '10px', cursor: 'pointer' }}
                  >
                    <Link
                      to={`/posts/${post.id}`}
                      className="card-body"
                      style={{ textDecoration: 'none' }}
                    >
                      <h3 className="card-title">{post.title}</h3>
                      <p className="card-name">
                        <PostAuthor userId={post.userId} />
                      </p>
                      <p className="card-body">{post.content}</p>
                      <p className="card-date">
                        <TimeAgo timestamp={post.date} />
                      </p>
                    </Link>
                    <div className="button_list">
                      <ReactionButtons reactions={post.reactions} id={post.id} />
                    </div>
                  </div>
                );
              };

              export default PostCard;


        postSlice.js(change code)
             
              const postsAdapter = createEntityAdapter({
                sortComparer: (a, b) => b.date.localeCompare(a.date),
              });

              const initialState = postsAdapter.getInitialState({
                // We not write posts: [] because postsAdapter have Default []
                status: 'idle', //'idle' | 'loading' | 'succeeded' | 'failed'
                fetchError: null,
                count: 0,
              });

              const postSlice = createSlice({
                name: 'posts',
                initialState,
                reducers: {
                  //or postUpdate can work as reactionAdded
                  reactionAdded(state, action) {
                    const { postId, reaction } = action.payload;
                    const existingPost = state.entities[postId];

                    if (existingPost) {
                      existingPost.reactions[reaction]++; //is work
                    }
                  },

                  increaseCount(state, action) {
                    state.count += 1;
                  },
                },
                extraReducers(builder) {
                  builder
                    .addCase(fetchPosts.pending, (state, action) => {
                      state.status = 'loading';
                    })
                    .addCase(fetchPosts.fulfilled, (state, action) => {
                      state.status = 'succeeded';
                      //state.posts = action.payload;
                      // Add any fetched posts to the array
                      postsAdapter.upsertMany(state, action.payload);
                    })
                    .addCase(fetchPosts.rejected, (state, action) => {
                      state.status = 'failed';
                      state.error = action.error.message;
                    })
                    .addCase(apiRequest.fulfilled, (state, action) => {
                      // state.posts.push(action.payload)
                      //state.status = 'idle';
                      //console.log(action.meta.arg.method);

                      switch (action.meta.arg.method) {
                        case 'put':
                          postsAdapter.upsertOne(state, action.payload);
                          break;
                        case 'delete':
                          const id = action.meta.arg.url.split('/');
                          postsAdapter.removeOne(state, id[id.length - 1]);
                          break;
                        case 'post':
                          postsAdapter.addOne(state, action.payload);
                          break;
                        default:
                          state.status = 'idle';
                          break;
                      }
                    });
                },
              });

              //getSelectors creates these selectors and we rename them with aliases using destructuring
              // postsAdapter.getSelectors have  own methods (selectAll,selectById,selectIds ...) we just changed the name.
              export const {
                selectAll: selectAllPosts,
                selectById: selectPostById,
                selectIds: selectPostIds,
                // Pass in a selector that returns the posts slice of state
              } = postsAdapter.getSelectors(state => state.posts);


    